# Title

* Building software to last 10,000 years

# Abstract

You just committed some new code and pushed it to production. It's live! But for how long? A week? A month? A year? How about ten thousand years?

In this talk, we'll explore some really old software, and why we still need it.  We'll look at some core design principles for intentionally creating software to last a long time, with some help from other technologies. And, we'll discuss the tradeoffs of designing for longevity vs. flexibility.

# Description

You just committed some new code and pushed it to production. It's live! But for how long? A week? A month? A year? How about ten thousand years?

As software developers, we view what we build as being far more ephemeral than nearly any other profession. The shelf life on our work is usually measured in years, not decades or centuries. However, there is some software that has been running for a long time...  perhaps longer than it's creators intended.

In this talk, we'll explore some really old software, and why we still need it.  We'll look at some core design principles for intentionally creating software to last a long time, with some help from other technologies. And, we'll discuss the tradeoffs of designing for longevity vs. flexibility.

# Audience

This talk is for anyone that wants to build software that won't just get thrown away in a short amount of time.

Attendees should have a general knowledge of software best practices but don't require any specific background knowledge.

After watching the talk, attendees should have an understanding of how to build software that is robust, maintainable, understandable, and scalable, as well as how these practices have been adopted into the design of existing software projects.

# Outline

* Introduction (3 mins)
* Examples of long-running software systems (7 minutes)
    * NYC Subway System
    * MOCAS (Mechanization of Contract Administration Services)
    * Voyager 1 and 2
    * Python Package Index
* Core design principles (13 minutes)
    * Longevity
    * Maintainability
    * Transparency
    * Evolvability
    * Scalability
* Tradeoffs of design (5 min)
    * Ephemerality: Software vs physical objects
    * Longevity vs flexibility
* Conclusion (2 mins)

# Referencs

https://www.embedded.com/electronics-blogs/max-unleashed-and-unfettered/4443344/Meet-the-world-s-oldest-computer-program-that-s-still-in-use-today
https://www.technologyreview.com/s/538966/what-is-the-oldest-computer-program-still-in-use/
https://bdmpublications.com/10-ancient-computers-still-use-today/
https://tedium.co/2019/06/13/nyc-subway-os2-history/
