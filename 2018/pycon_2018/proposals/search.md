# Title

* Search is Hard!

# Description

Adding the ability to search is possibly one of the easiest-to-request features for a software project, but can be considered one of the hardest to implement -- and even harder to get right!

In this talk, we'll implement an extremely naive text search engine from scratch, and then add different search techniques in an attempt to improve the quality of the results. We'll discuss different ways to measure quality of a search algorithm, as well as methods for optimization.

# Who and Why

This talk is for anyone who has used a search engine and has wondered how it works, as well as for developers who have needed to implement some form of search in their projects and have needed to understand the trade offs and the complexity that comes with different search techniques.

This talk requires that the audience understand the motivation for needing search, and a general idea for what it might take for a search algorithm to work correctly, as well as a novice-level experience with Python.

After watching this talk, attendees should have a greater understanding for the complexity of search, some specific understanding for different search techniques and how they work, as well as when to use them and when what they've got is good enough.

# Outline

* Introduction (1 min)
  - Who am I?
* Search is Hard! (3 min)
  - Why search sounds easy
  - Why we miss the complexity
* Measuring quality (3 min)
  - Precision vs Quality
  - False Positives
* Search Techniques
  - Native Approach (4 min)
    * Serial Scanning
  - Indexing vs Searching (3 min)
  - Keyword Search (4 min)
  - Tokenization (5 min)
    * Stemming
    * Lemmatization
    * Filters
    * Stop Words
  - Controlled Vocabulary (3 min)
  - Concept Search (3 min)
* Conclusion (1 min)
